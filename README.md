# Тестовое задание

## Задание 1: Русским языком, текстом, описать алгоритм работы проекта с момента загрузки всех классов модулей до окончания процесса рендеринга всех компонентов.

1) импортируются модули Component, App и Button
2) Затем идет обращение к статическому свойству конструктора класса Component, которое является объектом и хранит ассоциации имя - класс. В него записывается класс Button с ключом c-button. в последующем это нужно при построении дом-дерева, по ключу будут искаться классы, от которых будут создаваться экземпляры класса (имя ключа === имя тега)
3) Создается экземпляр класса App с передачей props
4) В экземпляр класса App устанавливаются значения свойств template_content и template_file по умолчанию в значение undefined, а переданные props записываются в новое свойство props (в объект).
5) вызывается асинхронный метод render из модуля Component, т.к. App наследован от него
6) в методе рендер в константу dom парсится будущее dom-дерево из шаблона. при этом используется await, что заставляет интерпретатор ждать завершения работы (promise (и вложенных в него promises)
как происходит парсинг:
- в геттере dom идет обращение к геттеру template
- в template выполняется промис. если контент шаблона в свойствах не определен, то он будет пытаться считаться из файла шаблона. если файл шаблона не определен, то он собирается из строк "./" - текущий каталог, затем следует имя класса App, затем добавляется расширение ".html". Когда получено имя файла шаблона (из свойств или только что собрано), делается запрос к файлу, считывается его текст и записывается в свойство template_content. Промис возвращает это значение (контент шаблона) промису, который определен в геттере dom. Далее происходит парсинг с помощью DOMParser() и в свою очередь промис геттера dom возвращает готовый DOM в константу dom метода render. (наверное ничего не понятно, но лучше изложить не получилось)
7) далее в методе render при помощи await вызывается функция renderWithBody, которая в свою очередь вызывает renderChilds, которая рекурсивно рендерит дочерние элементы.
При рендеринге дочерних элементов проверяется каждый узел.
- eсли тип узла говорит о том что это просто текст, то вызывается функция парсинга строки. Переданная строка итерируется при помощи matchAll, а именно возвращаются все совпадения по регулярному выражению, т.е само выражение вместе с двойными усатыми скобками и его сожержимое, все это помещается в массив.
Затем создаются переменные, в которые помещается выражение и содержимое. Далее исходная строка заменяет {{выражение}} на значение. Это значение, в свою очередь, возвращает асинхронная функция _get_value (судя по имени, для внутреннего использования). Эта функция вызывает другую, _get, которая ищет по переданному имени значение из this.props, и если оно не равно undefined, возвращает его, иначе поиск идет в this. После того, как _get_value получила значение, оно проверяется, и если оно не определено, то пытается распарситься строка JSON из переданного параметра name. После того как подстановка значения вместо {{выражения}} завершена, оно выводится в value текущего текстового узла.
- если тип узла - тэг, получаем имя тега из узла в нижнем регистре. Также пытаемся получить класс (tag_class), который записан в статическом свойстве конструктора Component по имени тэга (см п.2). Затем парсим в переменную props аттрибуты будущего тега при помощи функции parseAttributes. Эта функция возвратит объект с измененными атрибутами, которые начинаются с символов "@" и ":". Асинхронная функция парсинга пробегается по коллекции объектов Attr, удаляет первый символ у имени аттрибута и записывает получивщееся имя в name1. Далее, если первый символ имени был:
  - символ ":" - снова вызывается функция _get_value и ищет переданное значение в this или в this.props, как и при парсинге строки. найденное значение подставляется в возвращаемый объект по ключу name1 (без символа ":")
  - символ "@" - в существующее свойство _event возвращаемого объекта, или в новое свойство _event (если оно еще не было определено), записывается функция-обработчик события, которая возвращается функцией _get (ищется по переданному имени name1 в this или this.props), name1 - имя аттрибута с обрезанным первым символом.
Далее, если у нас ранее был определен класс для текущего узла (tag_class), то мы создаем новый экземпляр этого класса с передачей подготовленных props для него и рендерим узел. Иначе продолжаем рендер дочерних компонентов текущего узла (тэга).
И так происходит пока не отрендерятся все дочерние компоненты всех узлов.

## Задание 2: 

Подключить к проекту CSS фреймворк Bootstrap 4. С использованием классов из фреймворка сделать кнопку большой и первичной (primary).

При помощи inline стилей без использования графических файлов (картинок) покрасить кнопку следующим образом:
* градиент по диагонали от розового до бурого
* скругления углов кнопки всех кроме правого верхнего
* под кнопкой нарисовать тень с сильным размытием и со смещением вправо вниз

__Решение: Задание выполнено прямо в шаблоне кнопки__

## Задание 3: 
Дописать класс Component таким образом, чтобы в момент рендеринга компонента
### 3.1
при нахождении аттрибута тега начинающегося с “@” (собачки) на него навешивался соответствующий слушатель события, исходный аттрибут должен быть удален, 
### 3.2
 а при нахождении аттрибута тега начинающегося с “:” (двоеточия) он заменялся на аттрибут без “:”, но с окончательным расчетным значением, как в случае с уже реализованной подстановкой строки через оператор {{}}




